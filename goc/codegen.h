#ifndef CODEGEN_H
#define CODEGEN_H

#include "parser.h"
#include <vector>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <cstdint>

enum class Opcode : uint8_t {
    PUSH        = 0x01,
    POP         = 0x02,
    ADD         = 0x03,
    SUB         = 0x04,
    MUL         = 0x05,
    DIV         = 0x06,
    MOD         = 0x07,
    DUP         = 0x08,
    SWAP        = 0x09,
    PRINT       = 0x0A,
    PRINT_STR   = 0x0B,  // Print string by ID
    INPUT_STR   = 0x0C,  // Input string
    INPUT       = 0x0D,
    JMP         = 0x10,
    JZ          = 0x11,
    JNZ         = 0x12,
    JL          = 0x13,
    JG          = 0x14,
    JLE         = 0x15,
    JGE         = 0x16,
    CMP         = 0x17,
    CALL        = 0x18,
    RET         = 0x19,
    LOAD        = 0x20,
    STORE       = 0x21,
    LOAD_BP     = 0x22,
    STORE_BP    = 0x23,
    PUSH_BP     = 0x24,
    POP_BP      = 0x25,
    PUSH_STR    = 0x26,  // Push string ID onto stack
    LOAD_INDIRECT  = 0x27,  // Pop address, load mem[addr], push value
    STORE_INDIRECT = 0x28,  // Pop addr, pop value, store mem[addr] = value
    ALLOC       = 0x29,     // Pop size, allocate heap memory, push address
    FREE        = 0x2A,     // Pop address, free heap memory

    // FPU (x87-style circular register stack, 8 slots)
    FPUSH       = 0x30,  // 4-byte float immediate → push to FPU stack
    FPOP        = 0x31,  // discard FPU ST0
    FADD        = 0x32,  // b=fpop, a=fpop, fpush(a+b)
    FSUB        = 0x33,  // b=fpop, a=fpop, fpush(a-b)
    FMUL        = 0x34,  // b=fpop, a=fpop, fpush(a*b)
    FDIV        = 0x35,  // b=fpop, a=fpop, fpush(a/b)
    FLOAD       = 0x36,  // read addr(int32), push float_memory[addr] to FPU
    FSTORE      = 0x37,  // read addr(int32), pop FPU ST0 → float_memory[addr]
    FPRINT      = 0x38,  // print ST0, pop FPU
    FCMP        = 0x39,  // b=fpop, a=fpop, set cmp_flag = (a<b)?-1:(a>b)?1:0
    FNEG        = 0x3A,  // ST0 = -ST0
    FDUP        = 0x3B,  // push copy of ST0
    INT_TO_FP   = 0x3C,  // pop int stack, convert, push to FPU
    FP_TO_INT   = 0x3D,  // pop FPU, truncate, push to int stack

    HALT        = 0xFF
};

// Symbol information
struct Symbol {
    enum Type { VARIABLE, FUNCTION, PARAMETER };
    Type type;
    int offset;      // Stack offset for variables/params
    int address;     // Code address for functions
    int param_count; // For functions
    bool is_array;   // True if this is an array or pointer
    bool is_heap_allocated; // True if allocated with "new"
    bool is_float;   // True if this is a float/double variable
};

class CodeGenerator {
public:
    CodeGenerator();
    
    // Main entry point
    std::vector<uint8_t> generate(const Program& program);
    
    // Save bytecode to file
    bool saveToFile(const std::string& filename);
    
    // Get generated bytecode
    const std::vector<uint8_t>& getBytecode() const { return bytecode; }
    
    // Display bytecode (for debugging)
    void dumpBytecode() const;
    
private:
    std::vector<uint8_t> bytecode;
    std::unordered_map<std::string, Symbol> symbols;
    std::unordered_set<std::string> class_names;  // Track class/struct names
    std::vector<std::string> string_table;        // String literals
    int current_offset;     // Current stack offset
    int next_memory_addr;   // Next available memory address
    
    // Code generation for different AST nodes
    void genProgram(const Program& prog);
    void genStatement(const ASTNode* node);
    void genExpression(const ASTNode* node);
    void genVarDecl(const VarDecl* decl);
    void genFunctionDecl(const FunctionDecl* func);
    void genFunctionDecl(const FunctionDecl* func, const std::string& nameOverride);
    void genBlock(const BlockStmt* block);
    void genIf(const IfStmt* ifstmt);
    void genWhile(const WhileStmt* whilestmt);
    void genFor(const ForStmt* forstmt);
    void genReturn(const ReturnStmt* ret);
    void genBinaryOp(const BinaryOp* binop);
    void genUnaryOp(const UnaryOp* unop);
    void genCall(const CallExpr* call);
    void genLiteral(const Literal* lit);
    void genIdentifier(const Identifier* id);
    void genArraySubscript(const ArraySubscript* sub);
    
    // Helper methods
    void emit(Opcode op);
    void emitByte(uint8_t byte);
    void emitInt32(int32_t value);
    void emitInt32At(size_t pos, int32_t value);
    size_t currentAddress() const { return bytecode.size(); }
    
    // Label management for jumps
    struct Label {
        std::vector<size_t> fixup_positions;
        int address;
        bool defined;
    };
    std::unordered_map<std::string, Label> labels;
    int label_counter;
    
    std::string makeLabel(const std::string& prefix);
    void defineLabel(const std::string& label);
    void emitJump(Opcode op, const std::string& label);
    void fixupLabels();
    
    // String table management
    int addString(const std::string& str);
    
    // Name mangling for function overloading
    std::string mangleFunctionName(const std::string& name, int param_count);
    std::string mangleFunctionName(const std::string& name, const std::vector<std::pair<std::vector<std::string>, std::string>>& params);
    
    // Symbol table management
    void enterScope();
    void exitScope();
    void addVariable(const std::string& name, int offset, bool is_array = false, bool is_heap_allocated = false, bool is_float = false);
    void addParameter(const std::string& name, int offset);
    void addFunction(const std::string& name, int address, int param_count);
    Symbol* findSymbol(const std::string& name);

    // Float helpers
    static bool isFloatLiteralStr(const std::string& s);
    static bool isFloatType(const std::vector<std::string>& typeTokens);
    bool isFloatExpr(const ASTNode* node);
    void emitFloat32(float value);
};

#endif // CODEGEN_H
