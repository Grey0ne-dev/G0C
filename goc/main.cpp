#include "lexer.h"
#include "parser.h"
#include "codegen.h"
#include <iostream>
#include <string>

void printHelp() {
    std::cout << "Usage: compiler [options] <input file>\n"
              << "Options:\n"
              << "  -h, --help            Show this help message\n"
              << "  -s, --stats           Show only statistics\n"
              << "  -o, --output <file>   Save bytecode to file\n"
              << "  -v, --verbose         Enable verbose output\n"
              << "  -q, --quiet           Suppress all verbose output\n"
              << "  --stage <name>        Stop at specific stage: lex | parse | codegen\n"
              << "  --dump-ast            Dump Abstract Syntax Tree\n"
              << "  --dump-tokens         Dump token list\n"
              << "  --dump-bytecode       Dump generated bytecode\n"
              << std::endl;
}

struct CompilerFlags {
    bool show_help = false;
    bool show_stats_only = false;
    bool verbose = false;
    bool dump_ast = false;
    bool dump_tokens = false;
    bool dump_bytecode = false;
    std::string input_file;
    std::string output_file;
    std::string stage = "codegen";
    float version = 4.2;
};

bool parse_command_line(int argc, char** argv, CompilerFlags& flags) {
    for (int i = 1; i < argc; i++) {
        std::string arg = argv[i];

        if (arg == "--version") {
            std::cout << "GOC version: " << flags.version << std::endl;
            std::cout << "This is free software; see the source for copying conditions.  There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.";
            std::cout << std::endl;
            exit(0);
        }
        else if (arg == "-h" || arg == "--help") {
            flags.show_help = true;
        } else if (arg == "-s" || arg == "--stats") {
            flags.show_stats_only = true;
            flags.verbose = false;
        } else if (arg == "-o" || arg == "--output") {
            if (i + 1 < argc) {
                flags.output_file = argv[++i];
            } else {
                std::cerr << "Error: missing filename after -o option\n";
                exit(1);
            }
        } else if (arg == "-v" || arg == "--verbose") {
            flags.verbose = true;
        } else if (arg == "-q" || arg == "--quiet") {
            flags.verbose = false;
        } else if (arg == "--stage") {
            if (i + 1 < argc) {
                flags.stage = argv[++i];
            } else {
                std::cerr << "Error: missing argument after --stage\n";
                exit(1);
            }
        } else if (arg == "--dump-ast") {
            flags.dump_ast = true;
        } else if (arg == "--dump-tokens") {
            flags.dump_tokens = true;
        } else if (arg == "--dump-bytecode") {
            flags.dump_bytecode = true;
        } else if (arg[0] == '-') {
            std::cerr << "Undefined option: " << arg << "\n";
            printHelp();
            exit(1);
        } else {
            flags.input_file = arg;
        }
    }
    
    return true;
}

Lexer performLexicalAnalysis(const std::string& input_file, const CompilerFlags& flags) {
    if (flags.verbose) {
        std::cout << "=== C++ Compiler Frontend ===\n";
        std::cout << "Input file: " << input_file << "\n";
        std::cout << "\n[1. Lexical Analysis]\n";
    }

    std::string source_code = readFile(input_file);
    Lexer lexer(source_code, input_file);
    auto tokens = lexer.tokenize();

    if (lexer.hasErrors()) {
        std::cerr << "\nLexical errors detected. Stopping.\n";
        exit(1);
    }

    if (flags.dump_tokens) {
        lexer.printTokens(true);
    } else {
        std::cout << "Tokens generated: " << tokens.size() << "\n";
    }

    if (flags.show_stats_only) {
        lexer.printStatistics();
    }

    return lexer;
}

Program performParsing(const std::vector<Token>& tokens) {
    std::cout << "Syntax analysis: building AST...\n";
    Parser parser(tokens);
    Program ast = parser.parseProgram();

    std::cout << "✓ Parsing completed successfully!\n";
    std::cout << "Top-level declarations: " << ast.top.size() << "\n";

    return ast;
}

void saveBytecodeToFile(CodeGenerator& codegen, const std::string& output_file, bool verbose) {
    if (!output_file.empty()) {
        if (!codegen.saveToFile(output_file)) {
            std::cerr << "Error: Failed to save bytecode to file\n";
            exit(1);
        }
        if (verbose) {
            std::cout << "✓ Bytecode saved to: " << output_file << "\n";
        }
    }
}

int main(int argc, char* argv[]) {
    CompilerFlags flags;
    
    parse_command_line(argc, argv, flags);

    if (flags.show_help) {
        printHelp();
        return 0;
    }

    if (flags.input_file.empty()) {
        std::cerr << "Input file is not specified\n";
        printHelp();
        return 1;
    }

    try {
        // --- STEP 1: LEXICAL ANALYSIS ---
        Lexer lexer = performLexicalAnalysis(flags.input_file, flags);
        auto tokens = lexer.tokenize();

        if (flags.stage == "lex") {
            if (flags.verbose) std::cout << "\nStopping after lexical analysis (--stage lex)\n";

            if (!flags.output_file.empty()) {
                if (lexer.saveTokensToFile(flags.output_file)) {
                    std::cout << "Tokens saved to: " << flags.output_file << "\n";
                } else {
                    std::cerr << "Error: could not save tokens to file " << flags.output_file << "\n";
                }
            }
            return 0;
        }

        // --- STEP 2: PARSING ---
        Program ast = performParsing(tokens);

        if (flags.dump_ast) {
            std::cout << "\n[Abstract Syntax Tree]\n";
            std::cout << "=======================\n";
            ast.dump();
            std::cout << "\n";
        }

        if (flags.stage == "parse") {
            if (flags.verbose) {
                std::cout << "\n✓ Stopping after parsing (--stage parse)\n";
                std::cout << "✓ AST contains " << ast.top.size() << " top-level nodes\n";
            }
            return 0;
        }

        // --- STEP 3: CODE GENERATION ---
        std::cout << "Code generation: generating bytecode...\n";
        CodeGenerator codegen;
        auto bytecode = codegen.generate(ast);

        std::cout << "✓ Code generation completed!\n";
        std::cout << "Generated " << bytecode.size() << " bytes of bytecode\n";

        if (flags.dump_bytecode) {
            codegen.dumpBytecode();
        }

        // Save bytecode to file
        if (!flags.output_file.empty()) {
            saveBytecodeToFile(codegen, flags.output_file, flags.verbose);
        } else if (flags.stage == "codegen") {
            std::string default_output = flags.input_file;
            size_t dot_pos = default_output.find_last_of('.');
            if (dot_pos != std::string::npos) {
                default_output = default_output.substr(0, dot_pos);
            }
            default_output += ".bin";
            
            saveBytecodeToFile(codegen, default_output, flags.verbose);
        }

        if (flags.stage == "codegen") {
            std::cout << "Stopping after code generation (--stage codegen)\n";
            return 0;
        }

        // --- FINAL SUMMARY ---
        std::cout << "\n=== Compilation Summary ===\n";
        std::cout << "Lexical analysis: " << tokens.size() << " tokens\n";
        std::cout << "Syntax analysis: " << ast.top.size() << " top-level AST nodes\n";
        std::cout << "Code generation: " << bytecode.size() << " bytes\n";
        std::cout << "\nCompilation completed successfully!\n";

        return 0;

    } catch (const std::exception& e) {
        std::cerr << "\n❌ ERROR: " << e.what() << "\n";
        return 1;
    } catch (...) {
        std::cerr << "\n❌ UNKNOWN ERROR occurred\n";
        return 1;
    }
}
