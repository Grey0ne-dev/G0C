# GOC - Experimental C++ Compiler Frontend & Virtual Machine (Beta)

GOC (GreyOne Compiler) is an early **beta-version** compiler environment written entirely from scratch ‚Äî including lexer, parser, AST builder, bytecode generator, and a custom stack-based virtual machine. It is already capable of compiling and executing a subset of C++ code, demonstrating a fully working end-to-end compilation pipeline.

This project represents my **first deep dive into compiler engineering**, and **as a flex I decided to show some compiler theory stuff ‚Äî I basically turned C++ into Java )))**, just to demonstrate how flexible the pipeline already is., heavily inspired by the concepts, theory, and algorithms presented in the legendary "Dragon Book" (*Compilers: Principles, Techniques, and Tools*). I used its ideas as a foundation, but implemented every part myself ‚Äî from lexical analysis to VM execution.

---

## üöÄ Features (Current Beta)

### ‚úîÔ∏è Lexical Analysis

* Tokenizes C++-like input
* Supports identifiers, keywords, operators, numbers, braces, and preprocessors
* Outputs detailed token statistics

### ‚úîÔ∏è Syntax Analysis

* Recursive-descent parser for simplified C++ grammar
* Builds an **Abstract Syntax Tree (AST)**
* Supports:

  * variable declarations
  * arithmetic expressions
  * comparison operators
  * `while` loops
  * simple statements
  * `std::cout` output chains

### ‚úîÔ∏è Code Generation

* Walks the AST and emits bytecode for a custom stack-based virtual machine
* Machine operations include:

  * Load/store
  * Arithmetic ops
  * Comparisons
  * Conditional and unconditional jumps
  * Print operations

### ‚úîÔ∏è Virtual Machine (VM)

* Executes GOC bytecode
* Prints values during runtime
* Implements a clean instruction set and stack behavior
* Supports simple control flow, counters, and output

### Tooling & CLI

* goc (compiler): -h/--help; supports --dump-ast and --dump-bytecode to print AST and bytecode; -o <output> to set output filename.
* vm (virtual machine): -h/--help; -d/--debug to enable execution tracing; --disassemble to disassemble bytecode and exit.
* Disassembler: The VM can disassemble generated bytecode for inspection (vm.disassemble / --disassemble).
* Bytecode dump: The compiler frontend supports textual bytecode dumping for debugging and development via --dump-bytecode.
* Name mangling: Function overloading is supported using name mangling format: functionName_P<count>_<type1>_<type2>...
* String table: String literals are stored in a string table and referenced by PUSH_STR/PRINT_STR opcodes.
* FPU (floating-point): A small FPU stack (8 slots) is available with instructions: FPUSH (push float immediate), FPOP, FADD, FSUB, FMUL, FDIV, FLOAD, FSTORE, FPRINT (print and pop), FCMP (set comparison flag), FNEG, FDUP, INT_TO_FP, FP_TO_INT. Floating ops are emitted when expressions are detected as float by the code generator.

---

## üìå Example End-to-End Compilation

Input file:

```cpp
#include <iostream>

int main() {
    int i = 0;
    while(i < 10) {
        i = i + 1;
        std::cout << i;
    }
}
```

GOC compiles this into bytecode and the VM executes it, producing:

```
1
2
3
4
5
6
7
8
9
10
VM halted
```

This demonstrates the full pipeline working correctly.

---

## üî• Technical Architecture

### Note on Implementation History

Originally, the Virtual Machine backend was written in **NASM x86_64 assembly**, but was later fully **rewritten in C++ for comfort, portability, and easier debugging**. The current VM is cleaner and more maintainable while preserving the original low-level design philosophy.

---

### 1. Lexer (`Lexer`)

* Processes the input file character-by-character
* Generates tokens using deterministic scanning rules
* Inspired by Dragon Book lexical design, but tailored manually

### 2. Parser (`Parser`)

* Handwritten recursive-descent parser
* Grammar follows LL(1)-friendly patterns
* Produces typed AST nodes:

  * `BinaryExpression`
  * `VariableDeclaration`
  * `WhileStatement`
  * `PrintStatement`
  * etc.

### 3. AST Representation

* Every language construct is represented as a node
* Nodes are used directly by the code generator

### 4. Bytecode Generator (`Codegen`)

* Emits VM-friendly instructions
* Manages temporary stack usage
* Produces relocatable jump offsets

### 5. Virtual Machine (`VM`)

* Simple but powerful stack machine
* Fetch-decode-execute loop
* Instruction set includes:

  * **Stack**: PUSH, POP, DUP, SWAP
  * **Arithmetic**: ADD, SUB, MUL, DIV, MOD
  * **Control**: JMP, JZ, JNZ, JL, JG, JLE, JGE, CMP
  * **Functions**: CALL, RET, PUSH_BP, POP_BP
  * **Memory**: LOAD, STORE, LOAD_BP, STORE_BP, LOAD_INDIRECT, STORE_INDIRECT, ALLOC, FREE
  * **I/O**: PRINT, INPUT, PRINT_STR, INPUT_STR, PUSH_STR
  * **FPU/Float**: FPUSH, FPOP, FADD, FSUB, FMUL, FDIV, FPRINT, FCMP, FNEG, FDUP, INT_TO_FP, FP_TO_INT
  * **Control**: HALT

---

## üß™ Beta Status

This project **skips full semantic analysis and performs no optimization passes**. As a result, the workflow may be unstable in edge cases ‚Äî the compiler assumes valid code structure and may generate incorrect bytecode for ambiguous or invalid constructs.

Current limitations due to missing semantic analysis:

* No type-checking enforcement
* Undeclared variables may not be caught correctly
* No scope resolution rules
* No validation of operator types
* Potential undefined behavior during code generation

These parts are intentionally postponed to keep focus on architectural clarity and iterative learning.

This project still contains **placeholders for more complex C++ features**, such as:

* namespaces
* lambdas
* containers (std::vector, std::map, etc.)
* advanced expression handling
* fully compliant operator chains
* complete semantic analysis

These placeholders exist so the architecture can evolve naturally without breaking the current functional beta.

This is a **beta** version, meaning:

* language coverage is incomplete
* grammar is simplified
* error recovery is basic
* bytecode is not optimized
* VM uses minimal instruction set

**However:** the entire system is stable enough to compile real toy programs and execute them inside a controlled environment.

---

## üéØ Design Philosophy

* Build everything **from zero**, no external parsing libraries
* Understand each component deeply
* Keep the architecture modular and educational
* Make debugging easy via verbose logs
* Allow future extension toward a real optimizing compiler

---

## üìö Inspiration

This project is strongly influenced by:

### **The Dragon Book**

*Compilers: Principles, Techniques, and Tools* by Aho, Lam, Sethi, and Ullman.

Concepts borrowed:

* token definitions
* recursive-descent parsing strategies
* AST transformations
* stack machine design principles
* code generation patterns

But the implementation is entirely my own.

---

## üõ†Ô∏è Planned Features / Roadmap

* Support for `if` / `else`
* Functions and call stack
* Return values
* Local variable scopes
* String literals
* Real `std::cout << a << b` operator chaining
* Optimizer pass
* Disassembler for bytecode
* Register-based VM option
* Better error reporting

---

## ü§ù Contribution & Notes

This is a personal educational project. Contributions are welcome, but please understand:

* The architecture is intentionally low-level for learning
* Large rewrites may not align with the project‚Äôs educational purpose

---

## üìú License

Open-source, free for learning, modification, and experimentation.

---

## üí¨ Final Words

GOC is my **first real compiler**, built out of passion and curiosity. It's a massive learning journey inspired by the Dragon Book and powered by a desire to understand compilers from the inside out.

Even in beta, it already forms a fully functioning compilation toolchain.

More features, documentation, and refactoring coming soon.

**- Sergey Mkhoyan 3rd-semester group-402 (GreyOne)**
